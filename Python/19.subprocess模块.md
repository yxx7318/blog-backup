# subprocess模块

## Popen管理进程

`subprocess.Popen`的关键参数

- `args`：要执行的命令和参数，通常是一个字符串或一个程序参数的列表
- `stdin`，`stdout`，`stderr`：分别用来设置进程的标准输入、输出和错误。可以设置为 `subprocess.PIPE` 以便后续通过 `communicate()` 方法读取或写入
- `cwd`：设置子进程的当前工作目录
- `env`：设置子进程的环境变量
- `shell`：如果为 `True`，将通过shell执行指定的命令

```py
import subprocess
import os
import signal
import sys
import time


def kill_process_by_pid(pid):
    """
    尝试杀死指定PID的进程
    """
    try:
        if os.name == 'nt':
            # 在Windows上使用taskkill命令
            os.kill(pid, signal.SIGTERM)
            # SIGTERM信号在Windows上通常会被忽略如果杀死失败应该使用如下命令
            # subprocess.run(["taskkill", "/F", "/PID", str(pid)], check=True)
        else:
            # 在Linux上使用信号杀死进程
            os.kill(pid, signal.SIGTERM)
        time.sleep(1)
    except (OSError, subprocess.CalledProcessError) as e:
        print(f"无法杀死进程 {pid}: {e}，进程可能已经被杀死")


def write_pid_to_file(pid, filename):
    """
    将PID写入到文件中
    """
    with open(filename, 'w', encoding='utf-8') as file:
        file.write(str(pid))


def read_pid_from_file(filename):
    """
    从文件中读取PID
    """
    try:
        with open(filename, 'r', encoding='utf-8') as file:
            return int(file.read().strip())
    except FileNotFoundError:
        return None


def read_pid_and_kill(pid_filename):
    """
    读取PID并杀死进程
    """
    pid = read_pid_from_file(pid_filename)
    print(f'{pid_filename}:{pid}')
    if pid is not None:
        kill_process_by_pid(pid)


if __name__ == '__main__':
    pid_filename_fastapi = 'backend.pid'
    pid_filename_streamlit = 'frontend.pid'
    fastapi_port = '9894'
    streamlit_port = '8081'
    # 获取当前进程的PID
    pid = os.getpid()
    print(f"当前Python进程的PID是: {pid}")

    parameter1 = None
    # 检查是否有足够的参数
    # python main.py kill
    if len(sys.argv) > 1:
        # 获取第二个参数
        parameter1 = sys.argv[1]
        print(f"\n只执行进程杀死，输入参数为{parameter1}\n")
        parameter1 = True
    else:
        pass

    # 尝试杀死上次保存的main_fastapi.py进程
    read_pid_and_kill(pid_filename_fastapi)
    # 尝试杀死上次保存的main_streamlit.py进程
    read_pid_and_kill(pid_filename_streamlit)

    if not parameter1:
        print("\n-------启动进程-------\n")

        # 启动 main_fastapi.py 并将输出重定向到 backend.log
        with open('backend.log', 'w') as log_file_fastapi:
            process_fastapi = subprocess.Popen(
                ['uvicorn', 'main_fastapi:app', '--host', '0.0.0.0', '--port', f'{fastapi_port}'],
                stdout=log_file_fastapi,
                stderr=subprocess.STDOUT)
            print(f"main_fastapi.py process ID: {process_fastapi.pid}")
            write_pid_to_file(process_fastapi.pid, pid_filename_fastapi)

        # 启动 main_streamlit.py 并将输出重定向到 frontend.log
        with open('frontend.log', 'w') as log_file_streamlit:
            process_streamlit = subprocess.Popen(
                ['streamlit', 'run', 'main_streamlit.py', '--server.port', f'{streamlit_port}'],
                stdout=log_file_streamlit,
                stderr=subprocess.STDOUT)
            print(f"main_streamlit.py process ID: {process_streamlit.pid}")
            write_pid_to_file(process_streamlit.pid, pid_filename_streamlit)

```

> 代码可以通过指定的命令运行同级目录下`main_fastapi.py`和`main_streamlit.py`代码文件，并指定日志输出，通过记录进程ID，后续运行时可以在杀死进程的基础上再重新启动服务