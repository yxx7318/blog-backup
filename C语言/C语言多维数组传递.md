# C语言多维数组传递

二维数组作为函数的参数，实参可以直接使用二维数组名，在被调用函数中可以定义形参所有维数的大小，也可以省略以为大小的说明。例如：(**如果是C语言实参使用数组的话，只能在带值初始化值时无需声明大小(`int a[] = {1,2,3}`)，不能在仅声明数组、未声明空间大小的情况下还通过下标进行赋值操作**)

```c
void find (char a[3][10]);
void find (char a[ ][10]);
```

也可以使用数组指针来作为函数参数，例如：

```c
void find (char (*p)[10]);
```

但是不能像下面这样使用，例如：

```c
void find (char a[ ][ ]);
void find (char a[3][ ]);
```

其本质原因还是因为——**C语言的多维数组本质上还是“一维”**，也就是说对于`a[3][4]`来说，其在内存上还是12个连续的存储空间，之所以允许形参`a[][4]`的声明方式，这是因为只要告诉**编译器多长切一段**即可，至于**开始切的地址**是由传入的数组是知道的(**此时对于作为实参的二维数组就不能使用编译时未知的量来定义了**)

## C语言传递二维数组

> 三种传递方式：
>
> - 通过指针的方式传递是由传入的地址开始的
> - 通过数组的方式传递是由实参自身性质决定的
> - 通过数组指针的方式传递是由实参自身性质决定的

```c
#include<stdio.h>

void hand(char *p);
void array(char a[][3]);
void arrayAndHand(char (*p)[3]); //需要定义列数

int main(){
	char map[3][3] = {{'1','2','3'},{'4','5','6'},{'7','8','9'}}; 
	char *p = &map[1][1]; //以第二行第二个的地址为初始地址
	hand(p); //输出结果为-->6 7
	p = map[1]; //以第二行为初始地址
	hand(p); //输出结果为-->5 6
	array(map); //传入的数组第二个'[]'必须为'3'才能编译成功
	arrayAndHand(map); //相当于直接传数组地址过去
}

void hand(char *p){
	printf(" %c",p[1]); //输出结果为初始地址的下一个地址所指向的值
	printf(" %c",*(p + 1) + 1); //输出结果为初始地址下一位的下一位
}

void array(char a[][3]){
	printf(" %c",a[2][1]); //按传入数组的正常顺序输出-->8
	printf(" %c",*(*(a + 1) + 2)); //输出结果为数组的第二行第三个-->6
}

void arrayAndHand(char (*p)[3]){
	printf(" %c",p[1][1]); //输出结果为数组的第二行第二个-->5
}
```

> 之所以可以通过数组指针的方式传递，其原因还是因为C语言的数组其实是被规定长度('[]')的特殊指针，一维数组可以直接指向数组，对于数组所规定的长度会自动由于两者定义数据类型一致，取值不会存在问题
>
> ```c
> 	int a[] = {1,2,3,4};
> 	int *p = &a[1]; //以数组的第二位作为指针的初始地址
> 	printf("  %d  ",p[1]); //输出3
> ```
>
> 对于多维数组，比一般的指针多了n - 1层标记，此时指针也需要使用n - 1个'[]'使其与指向的数组规定一致
>
> ```c
> 	int b[3][2][1] = {{{1},{2}},{{3},{4}},{{5},{6}}};
> 	int (*pp)[2][1] = b;
> 	printf("  %d  ",pp[1][1][0]); //输出4
> ```
>
> 又或者是数组在传递地址给指针时就以“一维的方式“来传递
>
> ```c
> 	int b[3][2][1] = {{{1},{2}},{{3},{4}},{{5},{6}}};
> 	int *pp1 = &b[1][1][0];
> 	printf("  %d  ",pp1[1]); //在b[1][1][0]的基础上往后走一位-->5
> ```
