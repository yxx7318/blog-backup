# Redis限流

## 计数器限流算法

核心思想：

- 在一个固定的时间窗口内，统计请求的数量
- 如果请求数量超过了设定的阈值，则拒绝后续的请求
- 时间窗口通常是一个固定的秒数（如 1 秒、1 分钟）

基本实现：

```lua
local key = KEYS[1]
local count = tonumber(ARGV[1])  -- 最大允许的请求数
local time = tonumber(ARGV[2])   -- 时间窗口长度（秒）

local current = redis.call('get', key)
if current and tonumber(current) > count then
    return tonumber(current)     -- 如果当前请求数已经超过阈值，直接返回
end

current = redis.call('incr', key)  -- 增加计数器
if tonumber(current) == 1 then
    redis.call('expire', key, time)  -- 设置过期时间
end

return tonumber(current)  -- 返回当前计数值
```

## 令牌桶算法

> [redis实现令牌桶的正确姿势_redis令牌桶-CSDN博客](https://blog.csdn.net/weixin_42645678/article/details/124428393)

核心思想：

- 桶中存储一定数量的令牌
- 系统以固定速率向桶中添加令牌，直到达到桶的最大容量
- 每次请求需要消耗一个或多个令牌才能被处理
- 如果桶中没有足够的令牌，则拒绝请求或让请求等待

## 算法对比

| 特性             | 计数器算法               | 令牌桶算法                   |
| :--------------- | ------------------------ | ---------------------------- |
| **复杂度**       | 简单                     | 较复杂                       |
| **实现成本**     | 低                       | 高                           |
| **流量平滑性**   | 差（可能出现突刺）       | 好（支持平滑流量）           |
| **突发流量支持** | 不支持                   | 支持                         |
| **适用场景**     | 对流量控制要求较低的场景 | 高并发、高性能系统           |
| **典型应用**     | API 网关简单限流         | 分布式限流、消息队列消费速率 |

> 计数器算法：
>
> - 适合对流量控制要求不高的场景
> - 实现简单，但存在“突刺”问题，不适合高并发环境
>
> 令牌桶算法：
>
> - 更适合高并发和高性能场景
> - 能够平滑流量并支持一定程度的突发流量
> - 实现稍复杂，但性能和效果更好