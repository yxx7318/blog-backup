# Redis限流

## 计数器限流算法

核心思想：

- 在一个固定的时间窗口内，统计请求的数量
- 如果请求数量超过了设定的阈值，则拒绝后续的请求
- 时间窗口通常是一个固定的秒数（如 1 秒、1 分钟）

基本实现：

```lua
local key = KEYS[1]
local count = tonumber(ARGV[1])  -- 最大允许的请求数
local time = tonumber(ARGV[2])   -- 时间窗口长度（秒）

local current = redis.call('get', key)
if current and tonumber(current) > count then
    return tonumber(current)     -- 如果当前请求数已经超过阈值，直接返回
end

current = redis.call('incr', key)  -- 增加计数器
if tonumber(current) == 1 then
    redis.call('expire', key, time)  -- 设置过期时间
end

return tonumber(current)  -- 返回当前计数值
```

## 令牌桶算法

> [redis实现令牌桶的正确姿势_redis令牌桶-CSDN博客](https://blog.csdn.net/weixin_42645678/article/details/124428393)

核心思想：

- 桶中存储一定数量的令牌
- 系统以固定速率向桶中添加令牌，直到达到桶的最大容量
- 每次请求需要消耗一个或多个令牌才能被处理
- 如果桶中没有足够的令牌，则拒绝请求或让请求等待

## 算法对比

| 特性             | 计数器算法               | 令牌桶算法                   |
| :--------------- | ------------------------ | ---------------------------- |
| **复杂度**       | 简单                     | 较复杂                       |
| **实现成本**     | 低                       | 高                           |
| **流量平滑性**   | 差（可能出现突刺）       | 好（支持平滑流量）           |
| **突发流量支持** | 不支持                   | 支持                         |
| **适用场景**     | 对流量控制要求较低的场景 | 高并发、高性能系统           |
| **典型应用**     | API 网关简单限流         | 分布式限流、消息队列消费速率 |

> 计数器算法：
>
> - 适合对流量控制要求不高的场景
> - 实现简单，但存在“突刺”问题，不适合高并发环境
>
> 令牌桶算法：
>
> - 更适合高并发和高性能场景
> - 能够平滑流量并支持一定程度的突发流量
> - 实现稍复杂，但性能和效果更好

```lua
local tokens_key = KEYS[1]  -- 令牌桶剩余令牌数存储键名
local timestamp_key = KEYS[2]  -- 上次令牌更新时间戳存储键名
local rate = tonumber(ARGV[1])  -- 令牌生成速率（令牌/秒）
local capacity = tonumber(ARGV[2])  -- 令牌桶最大容量
local now = tonumber(ARGV[3])  -- 当前时间戳（秒）
local requested = tonumber(ARGV[4])  -- 本次请求需要的令牌数

local fill_time = capacity/rate  -- 桶满所需时间（秒）
local ttl = math.floor(fill_time*2)  -- 键过期时间（取桶满时间的两倍）

-- 获取当前剩余令牌数（若不存在则初始化桶满）
local last_tokens = tonumber(redis.call('get', tokens_key))
if last_tokens == nil then
  last_tokens = capacity
end

-- 获取上次刷新时间（若不存在则初始化为0）
local last_refreshed = tonumber(redis.call('get', timestamp_key))
if last_refreshed == nil then
  last_refreshed = 0
end

-- 计算时间差（确保非负）
local diff_time = math.max(0, now-last_refreshed)
-- 计算新增令牌数（不超过桶容量）
local filled_tokens = math.min(capacity, last_tokens+(diff_time*rate))

-- 判断当前令牌是否满足请求
local allowed = filled_tokens >= requested
local new_tokens = filled_tokens  -- 默认不消耗令牌
local allowed_num = 0  -- 默认拒绝请求（0）

if allowed then
  new_tokens = filled_tokens - requested  -- 消耗请求令牌
  allowed_num = 1  -- 允许请求（1）
end

-- 更新存储（仅当TTL有效时）
if ttl > 0 then
  redis.call('setex', tokens_key, ttl, new_tokens)  -- 更新剩余令牌数并设置过期
  redis.call('setex', timestamp_key, ttl, now)  -- 更新刷新时间戳
end

return allowed_num  -- 返回请求是否允许（1/0）
```

> 说明：
>
> - **双键设计**：使用两个键分别存储令牌数和时间戳，避免并发冲突
> - **令牌补充逻辑**：`filled_tokens = min(容量, 当前令牌 + 时间差*速率)`实现按时间补充令牌
> - **动态TTL**：`ttl = fill_time*2`确保键过期时间大于桶填充周期
> - **原子操作**：整个计算和更新过程在Redis中原子执行
> - **返回值**：返回1表示允许请求，0表示拒绝（与计数器算法返回计数值不同）
>
> 特点：
>
> - **允许突发流量**：桶容量允许短时间内超过速率限制的请求
> - **平滑限流**：通过持续补充令牌实现平均速率控制
> - **低存储开销**：仅需存储两个键值对，通过TTL自动清理