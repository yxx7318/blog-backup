# 蓝绿部署

> **蓝绿部署是一种将新版本的应用部署在一个全新的环境中，待测试通过后再切换流量到新环境的部署方式**。 在蓝绿部署中，原有的稳定版本称为蓝环境，而新版本所在的环境称为绿环境。 通过切换路由或负载均衡器的方式，将用户的流量从蓝环境切换到绿环境，从而完成版本更新

## SpringBoot项目

> - Linux系统服务配置
> - Nginx不间断发布和负载均衡

### 系统服务配置

> 用于注册Springboot服务，并在启动服务前进行日志文件的重命名并锁定进程服务，防止异常杀死

日志重命名脚本`RotateLog.sh`：

```sh
#!/bin/bash

# 获取脚本所在的目录
SCRIPT_DIR=$(dirname "$(readlink -f "$0")")

# 封装日志文件重命名和创建新日志文件的函数
rotate_log_file() {
    local log_file="$1"
    local log_dir=$(dirname "$log_file")
    local log_base=$(basename "$log_file")
    local log_name="${log_base%.*}"  # 移除文件扩展名

    # 检查并创建 logs 子目录
    local log_subdir="${log_dir}/logs"
    mkdir -p "$log_subdir"

    # 检查是否需要重命名旧日志文件
    if [ -f "$log_file" ]; then
        # 获取当前时间戳
        local timestamp=$(date +"%Y%m%d-%H%M%S")
        # 重命名旧日志文件，添加时间戳后缀，并移动到 logs 子目录
        mv "$log_file" "${log_subdir}/${log_name}_${timestamp}.log"
    fi

    # 创建新日志文件
    touch "$log_file"

    # 设置正确的权限，以便服务可以写入日志文件
    # 请根据实际情况替换 springboot:springboot 为正确的用户和组
    # chown springboot:springboot "$log_file"
    echo "$log_file"
}

# 检查是否提供了日志文件路径作为参数
if [ $# -eq 0 ]; then
    # 如果没有提供日志文件路径，使用脚本所在目录
    LOG_FILE_PATH=$(find "$SCRIPT_DIR" -maxdepth 1 -name "*.log" -print -quit)
    if [ -z "$LOG_FILE_PATH" ]; then
        echo "脚本目录$SCRIPT_DIR没有查找到任何.log文件，您可以手动指定: sh $0 LOG_FILE_PATH"
    elif [ ! -z "$LOG_FILE_PATH" ]; then
        rotate_log_file "$LOG_FILE_PATH"
    fi
else
    # 如果提供了日志文件路径，使用该路径
    LOG_FILE_PATH="$1"
    # 调用函数，传递日志文件路径
    rotate_log_file "$LOG_FILE_PATH"
fi
```

> 添加权限：`chmod +x rotateLog.sh`

生成系统服务配置文件：`vim /lib/systemd/system/springboot.service`

```ini
[Unit]
Description=springboot daemon
After=network.target

[Service]
Type=simple
User=root
WorkingDirectory=/usr/local/springboot
ExecStartPre=/bin/sh -c 'source $(find "/usr/local/springboot" -maxdepth 1 -name "*.sh" -print -quit)'  # 指定启动前的脚本，重启时也会触发
ExecStart=/bin/sh -c '/usr/local/jdk/bin/java -jar $(find "/usr/local/springboot" -maxdepth 1 -name "*.jar" -print -quit) --server.port=7318 --spring.profiles.active=prod >> /usr/local/springboot/log.log 2>&1'
ExecStop=/bin/kill -TERM $MAINPID
ExecStopPost=/bin/sleep 3
TimeoutStopSec=10
Restart=always
RestartSec=1
# 较低版本的systemctl不支持
# StandardOutput=append:${SPRINGBOOT_PATH}/systemLogs/system-${SERVICE_NAME}-info.log
# StandardError=append:${SPRINGBOOT_PATH}/systemLogs/system-${SERVICE_NAME}-error.log
PrivateTmp=true

[Install]
WantedBy=multi-user.target
```

> 系统服务构建脚本`ProduceSpringBootSystemd.sh`：
>
> ```sh
> #!/bin/sh
> 
> # 检查是否提供了springboot的路径参数
> if [ $# -eq 0 ]; then
>     echo "使用方式: sh $0 SPRINGBOOT_PATH [SERVICE_NAME]"
>     return 1
> fi
> 
> # 可能需要修改定制的参数
> JAVA_HOME="/usr/local/jdk"
> PORT=7318
> ACTIVE="prod"
> 
> SPRINGBOOT_PATH="$1"
> SERVICE_NAME="${2:-springboot}"  # 如果第二个参数未提供，则默认服务名称为'springboot'
> 
> rm -f /lib/systemd/system/${SERVICE_NAME}.service
> 
> # mkdir -p ${SPRINGBOOT_PATH}/systemLogs
> 
> touch /lib/systemd/system/${SERVICE_NAME}.service
> 
> cat <<EOF > /lib/systemd/system/${SERVICE_NAME}.service
> [Unit]
> Description=springboot daemon
> After=network.target
> 
> [Service]
> Type=simple
> User=root
> WorkingDirectory=${SPRINGBOOT_PATH}
> ExecStartPre=/bin/sh -c 'sh $(find "${SPRINGBOOT_PATH}" -maxdepth 1 -name "*.sh" -print -quit)'
> ExecStart=/bin/sh -c '${JAVA_HOME}/bin/java -jar $(find "${SPRINGBOOT_PATH}" -maxdepth 1 -name "*.jar" -print -quit) --server.port=${PORT} --spring.profiles.active=${ACTIVE} >> "${SPRINGBOOT_PATH}"/log.log 2>&1'
> ExecStop=/bin/kill -TERM ${MAINPID}
> ExecStopPost=/bin/sleep 3
> TimeoutStopSec=10
> Restart=always
> RestartSec=1
> # 较低版本的systemctl不支持
> # StandardOutput=append:${SPRINGBOOT_PATH}/systemLogs/system-${SERVICE_NAME}-info.log
> # StandardError=append:${SPRINGBOOT_PATH}/systemLogs/system-${SERVICE_NAME}-error.log
> PrivateTmp=true
> 
> [Install]
> WantedBy=multi-user.target
> EOF
> 
> # 重新加载systemd以应用新的服务单元文件
> sudo systemctl daemon-reload
> 
> echo "服务文件 ${SERVICE_NAME}.service 已创建并重新加载。"
> ```

### Nginx配置文件

nginx.conf

```nginx
    upstream springboot {
        server localhost:7318 weight=10;
        server localhost:7319 weight=0;
    }


    server {
        listen 80;

        location / {
			proxy_set_header Host $http_host;
			proxy_set_header X-Real-IP $remote_addr;
			proxy_set_header REMOTE-HOST $remote_addr;
			proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
			proxy_set_header X-Forwarded-Proto $scheme;
			proxy_pass http://springboot/;
        }
    }
```

NginxSwitch.sh

```sh
#!/bin/bash

# 定义脚本所在目录
SCRIPT_DIR=$(dirname "${BASH_SOURCE[0]}")

# 定义服务器信息文件路径
CURRENT_SERVER_FILE="$SCRIPT_DIR/CurrentServer"
TARGET_SERVER_FILE="$SCRIPT_DIR/TargetServer"

# 定义 Nginx 配置文件路径
NGINX_CONF="/etc/nginx/nginx.conf"  # 根据实际情况修改

# 检查文件是否存在
if [ ! -f "$CURRENT_SERVER_FILE" ] || [ ! -f "$TARGET_SERVER_FILE" ]; then
  echo "错误: $CURRENT_SERVER_FILE 或 $TARGET_SERVER_FILE 未找到。"
  return 1
fi

# 读取当前和目标服务器的端口号
CURRENT_PORT=$(cat "$CURRENT_SERVER_FILE")
TARGET_PORT=$(cat "$TARGET_SERVER_FILE")

# 检查端口号是否为空
if [ -z "$CURRENT_PORT" ] || [ -z "$TARGET_PORT" ]; then
  echo "错误: 端口号为空。"
  return 1
fi

# 检查端口号是否为数字
if ! [[ "$CURRENT_PORT" =~ ^[0-9]+$ ]] || ! [[ "$TARGET_PORT" =~ ^[0-9]+$ ]]; then
  echo "错误: 无效的端口号格式。"
  return 1
fi

# 备份原始配置文件
cp "$NGINX_CONF" "$NGINX_CONF.bak"
echo "Nginx 配置文件已备份到 $NGINX_CONF.bak"

# 使用 sed 替换配置文件中的服务器信息
# 更新 CurrentServer 的权重为 0，TargetServer 的权重为 10
sed -i "s/server localhost:$CURRENT_PORT weight=[0-9]\+/server localhost:$CURRENT_PORT weight=0/" "$NGINX_CONF"
sed -i "s/server localhost:$TARGET_PORT weight=[0-9]\+/server localhost:$TARGET_PORT weight=10/" "$NGINX_CONF"

# 检查配置文件语法
nginx -t -c "$NGINX_CONF"
if [ $? -ne 0 ]; then
  echo "错误: Nginx 配置文件测试失败。正在恢复备份并退出。"
  mv "$NGINX_CONF.bak" "$NGINX_CONF"
  return 1
fi

# 重启 Nginx 服务
systemctl restart nginx

# 检查 Nginx 是否成功启动
if systemctl is-active --quiet nginx; then
  echo "Nginx 重启成功。"
else
  echo "错误: Nginx 重启失败。正在恢复备份并退出。"
  mv "$NGINX_CONF.bak" "$NGINX_CONF"
  return 1
fi

# 日志记录
LOG_TIME=$(date '+%Y-%m-%d %H:%M:%S')
echo "$LOG_TIME - Nginx 从端口 $CURRENT_PORT 切换到端口 $TARGET_PORT" >> "$SCRIPT_DIR/NginxSwitch.log"

# 交换 CurrentServer 和 TargetServer 文件中的内容
echo "$TARGET_PORT" > "$CURRENT_SERVER_FILE"
echo "$CURRENT_PORT" > "$TARGET_SERVER_FILE"

echo "Nginx 切换完成。"
```

### 切换脚本

执行脚本`SwitchSpringBoot.sh`

```sh
#!/bin/bash

# 获取脚本所在的目录路径
SCRIPT_DIR=$(dirname "${BASH_SOURCE[0]}")

# 切换到脚本所在的目录
cd "$SCRIPT_DIR" || { echo "错误: 无法更改目录到 $SCRIPT_DIR" >&2; return 1; }

# 定义文件路径
CURRENT_SPRINGBOOT_FILE="$SCRIPT_DIR/CurrentSpringBoot"
TARGET_SPRINGBOOT_FILE="$SCRIPT_DIR/TargetSpringBoot"

# 检查文件是否存在
if [ ! -f "$CURRENT_SPRINGBOOT_FILE" ] || [ ! -f "$TARGET_SPRINGBOOT_FILE" ]; then
  echo "错误: $CURRENT_SPRINGBOOT_FILE 或者 $TARGET_SPRINGBOOT_FILE 未找到。"
  return 1
fi

# 读取服务名称
CURRENT_SERVICE_NAME=$(cat "$CURRENT_SPRINGBOOT_FILE")
TARGET_SERVICE_NAME=$(cat "$TARGET_SPRINGBOOT_FILE")

# 检查是否为空
if [ -z "$CURRENT_SERVICE_NAME" ] || [ -z "$TARGET_SERVICE_NAME" ]; then
  echo "错误: 服务名称为空。"
  return 1
fi

# 启动 TargetSpringBoot 服务
echo "启动服务: $TARGET_SERVICE_NAME"
sudo systemctl start "$TARGET_SERVICE_NAME"

# 等待1分钟
sleep 60

# 执行 Nginx 切换脚本
echo "执行 NginxSwitch.sh..."
"$SCRIPT_DIR/NginxShell/NginxSwitch.sh"

# 再次等待1分钟
sleep 60

# 停止 CurrentSpringBoot 服务
echo "停止服务: $CURRENT_SERVICE_NAME"
sudo systemctl stop "$CURRENT_SERVICE_NAME"

# 交换两个文件中的服务名称
echo "交换服务 $CURRENT_SPRINGBOOT_FILE 和 $TARGET_SPRINGBOOT_FILE"
echo "$TARGET_SERVICE_NAME" > "$CURRENT_SPRINGBOOT_FILE"
echo "$CURRENT_SERVICE_NAME" > "$TARGET_SPRINGBOOT_FILE"

# 日志记录
LOG_TIME=$(date '+%Y-%m-%d %H:%M:%S')
echo "$LOG_TIME - 服务切换记录: $CURRENT_SERVICE_NAME -> $TARGET_SERVICE_NAME" >> "$SCRIPT_DIR/SwitchSpringBoot.log"

echo "服务切换完毕！"
```

