# 注解

> 注解（Annotation），也叫元数据。一种代码级别的说明

## 元注解

创建自定义注解需要使用`@interface`关键字，需要用到的元注解

- @Target：表示注解可以用在什么地方
  - ElementType.CONSTRUCTOR：构造器声明
  - **ElementType.FIELD**：字段声明（包括枚举类型）
  - ElementType.LOCAL_VARIABLE：局部变量声明
  - **ElementType.METHOD**：方法声明
  - ElementType.PACKAGE：包声明
  - **ElementType.PARAMETER**：参数声明
  - **ElementType.TYPE**：类、接口（包括注解类型）或枚举声明
- @Retention：表示需要在什么级别保存该注解信息
  - RetentionPolicy.SOURCE：注解将被编译器丢弃，字节码文件中不存在
  - RetentionPolicy.CLASS：注解在class文件中可用，但会在运行阶段被丢弃
  - **RetentionPolicy.RUNTIME**：JVM将在运行期也保留注释，因此可以通过反射机制读取注解的信息
- @Documented：将此注解包含在Javadoc中
- @Inherited：允许子类继承父类中的注解

## 解析注解

AnnotatedElement接口提供了解析注解的方法(Class对象下的)

- `public Annotation[] getDeclaredAnnotations()`：获取当前对象上面的所有注解对象
- `public T getDeclaredAnnotation(Class<T> annotationClass)`：获取指定的注解对象
- `public boolean isAnnotationPresent(Class<Annotation> annotationClass)`：判断当前对象上是否存在某个注解

## 自定义注解

> Pointcut表达式
>
> - `execution`：用于匹配方法执行的连接点。例如：`execution(public * *(..))`可以匹配所有的public方法
> - `@annotation`：用于匹配当前执行方法上的注解。例如：`@annotation(com.atguigu.boot.annotation.MyAnnotation)`可以匹配所有被MyAnnotation注解的方法
> - `@within`：用于匹配所注解的类型内的方法执行。例如：`@within(com.atguigu.boot.annotation.MyAnnotation)`可以匹配所有在被MyAnnotation注解的类型内执行的方法
> 
>ProceedingJoinPoint方法
> 
>```java
>         // 获取目标方法的签名
>         MethodSignature signature = (MethodSignature) proceedingJoinPoint.getSignature();
>         // 获取目标方法
>         Method method = signature.getMethod();
>         // 获取方法的目标类
>         Class<?> targetClass = method.getDeclaringClass();
>         // 获取方法的形参名
>         Parameter[] parameters = method.getParameters();
>         // 获取方法形参值(还未自动赋值，此时都为空)
>         Object[] args = proceedingJoinPoint.getArgs();
>         // 获取类的所有成员变量(Controller层没有定义成员变量)
>         Field[] fields = targetClass.getDeclaredFields();
>         // 获取类的所有构造方法(只有默认的构造方法)
>         Constructor<?>[] constructors = targetClass.getDeclaredConstructors();
> ```

MyAnnotation.java

```java
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target({ElementType.METHOD, ElementType.PARAMETER, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
public @interface MyAnnotation {

    String value() default "";

}
```

MyAnnotationAop.java

```java
import com.yxx.common.annotation.MyAnnotation;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Pointcut;
import org.aspectj.lang.reflect.MethodSignature;
import org.springframework.core.annotation.AnnotationUtils;
import org.springframework.stereotype.Component;

import java.lang.annotation.Annotation;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.lang.reflect.Parameter;
import java.util.Objects;

@Aspect
@Component
public class MyAnnotationAop {

    /**
     * 获取方法或者类上的注解对象
     */
    public MyAnnotation getMyAnnotation(ProceedingJoinPoint point) {
        MethodSignature signature = (MethodSignature) point.getSignature();
        MyAnnotation myAnnotation = AnnotationUtils.findAnnotation(signature.getMethod(), MyAnnotation.class);
        if (Objects.nonNull(myAnnotation)) {
            return myAnnotation;
        }
        return AnnotationUtils.findAnnotation(signature.getDeclaringType(), MyAnnotation.class);
    }

    // 生效范围为添加了此注解的方法或类
    @Pointcut("@annotation(com.yxx.common.annotation.MyAnnotation) || @within(com.yxx.common.annotation.MyAnnotation)")
    public void pointCutClassAndMethod() {
    }

    @Around("pointCutClassAndMethod()")
    public Object around(ProceedingJoinPoint proceedingJoinPoint) throws IllegalAccessException {

        MyAnnotation myAnnotation = getMyAnnotation(proceedingJoinPoint);
        // 获取输入注解的值
        System.out.println(myAnnotation.value());

        // 获取目标方法的签名
        MethodSignature signature = (MethodSignature) proceedingJoinPoint.getSignature();
        // 获取目标方法
        Method method = signature.getMethod();
        // 获取方法的目标类
        Class<?> targetClass = method.getDeclaringClass();
        // 获取方法的形参名
        Parameter[] parameters = method.getParameters();
        // 获取方法形参值(还未自动赋值，此时都为空)
        Object[] args = proceedingJoinPoint.getArgs();
        // 获取类的所有成员变量(Controller层没有定义成员变量)
        Field[] fields = targetClass.getDeclaredFields();
        // 获取类的所有构造方法(只有默认的构造方法)
        Constructor<?>[] constructors = targetClass.getDeclaredConstructors();

        System.out.println("目标方法为：" + method.getName());

        // 对参数进行遍历，判断参数是否加了注解@MyAnnotation
        for (Parameter param : parameters) {
            try {
                Annotation[] annotations = param.getAnnotations();
                for (Annotation annotation : annotations) {
                    if (annotation instanceof MyAnnotation) {
                        System.out.println("添加了MyAnnotation注解的参数：" + param.getName());
                    }
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        // 修改形参对象成员变量的值
        for (Parameter parameter : parameters) {
            // 获取形参名，为user
            System.out.println("方法的形参名为：" + parameter.getName());
            // 根据getType()方法获取形参的class对象
            Class<?> type = parameter.getType();
            // 获取成员变量
            Field[] typeFields = type.getDeclaredFields();
            // 开启第二个参数的修改权限
            typeFields[1].setAccessible(true);
            System.out.println("参数的值为：" + proceedingJoinPoint.getArgs()[0]);
            // 将第二个参数的值修改为0L(这里两个参数分别为：需要修改的对象，修改后的值)
            typeFields[1].set(proceedingJoinPoint.getArgs()[0], 0L);
            System.out.println("修改前的结果为：" + typeFields[1].get(proceedingJoinPoint.getArgs()[0]));
            System.out.println("第一次修改后的结果为：" + proceedingJoinPoint.getArgs()[0]);
        }

        // 遍历所有形参
        for (Object arg : args) {
            System.out.println("Argument: " + arg);
        }

        // 遍历所有成员变量
        for (Field field : fields) {
            System.out.println("Field: " + field.getName());
        }

        // 遍历所有构造方法
        for (Constructor<?> constructor : constructors) {
            System.out.println("Constructor: " + constructor.getName());
        }

        try {
            // 执行方法
            Object result = proceedingJoinPoint.proceed();
            // 获取方法的返回值
            System.out.println(result);
            System.out.println("方法执行成功");
        } catch (Throwable throwable) {
            throwable.printStackTrace();
        }
        // 修改方法的返回值，如果多个AOP，返回值为先拦截的那个方法的返回值
        return null;
    }

    // 匹配0个或多个任意类型的参数，匹配被@MyAnnotation注解的参数，后面可以跟0个或多个任意类型的参数
    @Around("execution(* *(.., @com.yxx.common.annotation.MyAnnotation (*), ..))")
    public Object aroundMethodWithAnnotatedParam(ProceedingJoinPoint joinPoint) throws Throwable {
        // 获取方法参数
        Object[] args = joinPoint.getArgs();
        MethodSignature signature = (MethodSignature) joinPoint.getSignature();
        Method method = signature.getMethod();

        // 查找带有@MyAnnotation注解的参数
        Annotation[][] parameterAnnotations = method.getParameterAnnotations();
        for (int i = 0; i < parameterAnnotations.length; i++) {
            for (Annotation annotation : parameterAnnotations[i]) {
                if (annotation instanceof MyAnnotation) {
                    MyAnnotation myAnnotation = (MyAnnotation) annotation;
                    String value = myAnnotation.value();
                    Object paramValue = args[i];

                    // 在这里处理带有注解的参数
                    System.out.println("参数 " + i + " 带有@MyAnnotation, value: " + value);
                    System.out.println("参数值: " + paramValue);
                }
            }
        }

        return joinPoint.proceed();
    }
}
```

> springaop默认是支持类和方法的，即使使用execution表达式可以支持到参数级别，一般来说对参数级别，可以实现接口`HandlerInterceptor`

TbTestUserController.java

```java
@MyAnnotation(value = "testClass") // 类上所有方法都触发
public class TbTestUserController extends BaseControllerPlus {

    private final ITbTestUserService tbTestUserService;

    @Operation(summary = "查询--测试单表生成列表")
    @PreAuthorize("@ss.hasPermi('business:user:list')")
    @GetMapping("/list")
    @MyAnnotation(value = "testMethod") // 方法上优先，只触发一次
    public PageResult<TbTestUserVO> list(@ParameterObject TbTestUserQueryDTO tbTestUserQueryDTO) {
        return tbTestUserService.selectTbTestUserVOPage(tbTestUserQueryDTO);
    }
```

> 打印结果为：
>
> ```
> testMethod
> 目标方法为：list
>方法的形参名为：arg0
> 形参的内容为：TbTestUserQueryDTO(userId=null, parentId=null, userName=test, password=null, status=null, registerDate=null, registerTime=null)
>修改前的结果为：0
> 第一次修改后的结果为：TbTestUserQueryDTO(userId=0, parentId=null, userName=test, password=null, status=null, registerDate=null, registerTime=null)
> Argument: TbTestUserQueryDTO(userId=0, parentId=null, userName=test, password=null, status=null, registerDate=null, registerTime=null)
> Field: tbTestUserService
> Constructor: com.yxx.business.controller.TbTestUserController
> 
> 
> com.yxx.common.core.domain.PageResult@5142be33
> 方法执行成功
> ```
