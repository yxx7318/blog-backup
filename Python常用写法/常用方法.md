# 常用方法

## 监听按键事件终止进程

```python
import multiprocessing
import keyboard

# 监听按键按下事件q，按下终止进程
def on_key_pressed(event):
    if event.name == 'esc':  # 如果按下的是 q 键
        # print('按下了 esc 键，终止操作')
        thread.terminate()
    else:
        # print('按下了', event.name, '键')
        pass


if __name__ == '__main__':
    # 创建一个进程来执行do_something方法
    thread = multiprocessing.Process(target=do_something)
    thread.start()

    # 监听按键按下事件
    keyboard.on_press(on_key_pressed)
```

## 获取详细的异常信息

```python
import traceback

if __name__ == '__main__':
    try:
        print(1//0)

    except Exception as e:
        # 获取详细的异常信息，包括代码行数
        error_msg = traceback.format_exc()
        print(error_msg)
        # 将异常信息保存到文本文件
        with open("error_log.txt", "a", encoding="utf-8") as file:
            file.write(error_msg + "\n")
```

> ```
> Traceback (most recent call last):
>   File "D:\project\GraduationProject\test.py", line 5, in <module>
>     print(1//0)
> ZeroDivisionError: integer division or modulo by zero
> ```

## 杀死指定监听端口进程

```python
import os
import psutil
import signal
import sys

def kill_processes_by_port(port):
    """
    根据端口号查找并终止所有占用该端口的进程及其子进程
    
    参数:
        port (int): 要查找的端口号
    """
    killed_pids = set()  # 用于记录已经终止的进程ID，避免重复操作
    
    try:
        # 获取所有网络连接
        for conn in psutil.net_connections():
            if conn.laddr and conn.laddr.port == port:
                pid = conn.pid
                if pid and pid not in killed_pids:
                    try:
                        # 获取进程对象
                        process = psutil.Process(pid)
                        
                        # 获取所有子进程
                        children = process.children(recursive=True)
                        
                        # 先终止子进程
                        for child in children:
                            try:
                                print(f"终止子进程: PID={child.pid}, 名称={child.name()}")
                                child.terminate()
                                child.wait(timeout=3)  # 等待进程终止，最多等待3秒
                                killed_pids.add(child.pid)
                            except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.TimeoutExpired):
                                # 进程可能已经终止，或者没有权限访问
                                pass
                        
                        # 终止主进程
                        print(f"终止主进程: PID={process.pid}, 名称={process.name()}")
                        process.terminate()
                        try:
                            process.wait(timeout=3)  # 等待进程终止，最多等待3秒
                        except psutil.TimeoutExpired:
                            # 如果普通终止失败，尝试强制终止
                            print(f"进程 {process.pid} 未正常终止，尝试强制终止")
                            process.kill()
                        
                        killed_pids.add(pid)
                        print(f"成功终止进程 {pid} 及其所有子进程")
                        
                    except (psutil.NoSuchProcess, psutil.AccessDenied) as e:
                        print(f"无法访问进程 {pid}: {e}")
                        continue
        
        if not killed_pids:
            print(f"未找到占用端口 {port} 的进程")
        else:
            print(f"已终止所有占用端口 {port} 的进程")
            
    except Exception as e:
        print(f"发生错误: {e}")
        sys.exit(1)

if __name__ == "__main__":
    if len(sys.argv) != 2:
        print("使用方法: python script.py <端口号>")
        sys.exit(1)
    
    try:
        port = int(sys.argv[1])
        kill_processes_by_port(port)
    except ValueError:
        print("错误: 端口号必须是整数")
        sys.exit(1)

```

