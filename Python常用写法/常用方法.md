# 常用方法

## 监听按键事件终止进程

```python
import multiprocessing
import keyboard

# 监听按键按下事件q，按下终止进程
def on_key_pressed(event):
    if event.name == 'esc':  # 如果按下的是 q 键
        # print('按下了 esc 键，终止操作')
        thread.terminate()
    else:
        # print('按下了', event.name, '键')
        pass


if __name__ == '__main__':
    # 创建一个进程来执行do_something方法
    thread = multiprocessing.Process(target=do_something)
    thread.start()

    # 监听按键按下事件
    keyboard.on_press(on_key_pressed)
```

## 获取详细的异常信息

```python
import traceback

if __name__ == '__main__':
    try:
        print(1//0)

    except Exception as e:
        # 获取详细的异常信息，包括代码行数
        error_msg = traceback.format_exc()
        print(error_msg)
        # 将异常信息保存到文本文件
        with open("error_log.txt", "a", encoding="utf-8") as file:
            file.write(error_msg + "\n")
```

> ```
> Traceback (most recent call last):
>   File "D:\project\GraduationProject\test.py", line 5, in <module>
>     print(1//0)
> ZeroDivisionError: integer division or modulo by zero
> ```

## 代理方法不断进行重试

```python
import time


# 代理重试方法，默认重试10次
def retry_agent(fun=None, retry_count=10, sleep_time=0.3):
    def decorator(func):
        def agent_method(*args, **kwargs):
            # 最近的非全局作用域（通常是嵌套函数的外层函数作用域），相当于函数运行时的外层函数作用域
            nonlocal retry_count
            while True:
                if retry_count > 0:
                    try:
                        result = func(*args, **kwargs)
                        return result
                    except Exception as e:
                        import traceback
                        # 获取详细的异常信息，包括代码行数
                        error_msg = traceback.format_exc()
                        print(error_msg)

                        retry_count -= 1
                        time.sleep(sleep_time)
                else:
                    raise Exception("重复次数超出限制")

        return agent_method

    # 如果是@retry_agent用法
    if fun:
        return decorator(fun)
    # 兼容@retry_agent()用法
    return decorator


@retry_agent(sleep_time=1)
def method(param):
    print("方法参数：", param)


if __name__ == '__main__':
    method(10)

```

