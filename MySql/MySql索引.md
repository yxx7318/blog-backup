# MySql索引

> 索引是数据库中用于快速查找数据的数据结构，类似于书籍的目录。它通过维护特定列的值与对应数据行位置的映射关系，大幅提升查询效率。

## 索引的意义

- 提升查询性能：避免全表扫描，将查询复杂度从`O(n)`降至`O(log n)`。例如，在百万条记录中，全表扫描可能需要秒级，而索引查询可能只需毫秒级
- 保证数据唯一性：唯一索引确保列值的唯一性
- 加速表连接：在`JOIN`操作中，索引可以快速定位关联表中的匹配行
- 优化排序和分组：对`ORDER BY`和`GROUP BY`操作进行优化，如果排序或分组字段有索引，可以直接利用索引的有序性，避免临时表排序

## 索引的类型

- 按功能分类
  - **普通索引**：最基本的索引类型
  - **唯一索引**：保证列值的唯一性
  - **主键索引**：特殊的唯一索引，不允许NULL值，每个表最多只能有一个主键索引
  - **全文索引**：用于全文搜索，适用于`MyISAM`和`InnoDB`引擎（MySQL 5.6+），用于快速匹配文本内容
  - **空间索引**：用于地理空间数据，使用较少

- 按列数分类
  - **单列索引**：只包含一个列的索引
  - **组合索引（联合索引）**：包含两个或更多个列的索引。这是实际项目中非常重要且常用的索引类型

## 索引的数据结构

**B+Tree 索引**

`B+Tree`是`B-Tree`的变种，也是目前关系型数据库中最常用、最有效的索引数据结构。

- **结构特点**：
  - 所有数据都存储在叶子节点（`Leaf Node`）中，非叶子节点（`Non-Leaf Node`）只存储键值（索引列的值）和指针
  - 叶子节点之间通过指针相连，形成了一个双向链表，这使得范围查询非常高效
- **查询过程**：查询时，从根节点开始，通过比较键值的大小来决定下一层要搜索的分支，直到找到对应的叶子节点，从而获取到数据。这个过程是平衡的，查询时间复杂度为 O(log n)，非常高效

**Hash 索引**

- **原理**：基于哈希表实现，只有精确匹配所有列的查询才有效。它对每一行数据计算一个哈希码，并将哈希码和指向数据的指针存储在哈希表中
- **优点**：如果查询条件能精确匹配所有索引列，Hash 索引的查询速度极快，时间复杂度接近 O(1)
- **缺点**：
  - 不支持范围查询：`WHERE price > 100`这样的查询无法使用哈希索引
  - 不支持排序
  - 不支持部分列匹配：对于复合哈希索引，必须使用所有索引列进行查询
  - 可能发生哈希冲突
  - `Memory`存储引擎显式支持`Hash`索引，而`InnoDB`支持**自适应哈希索引**，这是数据库内部自动优化的，用户无法手动创建

**其他索引**

针对特定数据类型（如地理空间(`R-Tree`)、文本(`Full-Text`)）的索引

## 索引的创建和使用

**创建索引**

> 可以在建表时创建，也可以在表创建后修改

**建表时创建**：

```sql
CREATE TABLE `user` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(100) NOT NULL,
  `email` varchar(100) NOT NULL,
  `age` int(11) DEFAULT NULL,
  `city` varchar(50) DEFAULT NULL,
  PRIMARY KEY (`id`), -- 主键索引
  UNIQUE KEY `uk_email` (`email`), -- 唯一索引
  KEY `idx_city` (`city`), -- 普通索引
  KEY `idx_city_age` (`city`, `age`) -- 复合索引
);
```

**前缀索引**：

> 针对字符串类型字段（如`VARCHAR`、`CHAR`、`TEXT`等）的优化方案。当字段定义的长度较长（例如`name`为`varchar(100)`甚至更长）时，直接对整个字段创建索引会占用大量存储空间，且查询时的IO效率较低。此时可以只截取字段的前N个字符创建索引，在保证区分度的同时减少索引体积

```sql
-- 建表时创建部分长度索引
CREATE TABLE `user` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(100) NOT NULL,
  -- 其他字段...
  KEY `idx_name_prefix` (`name`(20)) -- 只对name前20个字符创建索引
);

-- 表创建后添加部分长度索引
CREATE INDEX idx_name_prefix ON user(name(20));
-- 或使用ALTER TABLE语法
ALTER TABLE user ADD INDEX idx_name_prefix (name(20));
```

**修改表时添加**：

```sql
-- 添加普通索引
CREATE INDEX idx_name ON user(name);
-- 或者
ALTER TABLE user ADD INDEX idx_name (name);

-- 添加唯一索引
CREATE UNIQUE INDEX uk_email ON user(email);

-- 添加复合索引
CREATE INDEX idx_city_age ON user(city, age);
```

**删除索引**

```sql
DROP INDEX idx_name ON user;
```

**查看索引**

```sql
SHOW INDEX FROM user;
```

## 索引的最佳实践

- **为常用于查询条件的列创建索引**：`WHERE`子句、`JOIN`的连接条件、`ORDER BY`和 `GROUP BY`的列是首选
- **考虑使用复合索引，并遵守“最左前缀原则”**
- **最左前缀原则**：如果创建了 `(A, B, C)`的复合索引，那么它相当于创建了 `(A)`、`(A, B)`和 `(A, B, C)`三个索引。查询条件必须包含最左边的列 A，索引才会生效
- **示例**：索引 `(city, age)`
  - 有效查询：`WHERE city='北京'`， `WHERE city='北京' AND age=30`
  - 无效查询：`WHERE age=30`（无法使用该索引）
- **技巧**：将区分度最高（最唯一）的列放在复合索引的最左边
- **避免在索引列上使用函数或计算**：
  - **错误示例**：`WHERE YEAR(create_time) = 2023`（索引可能失效）
  - **正确示例**：`WHERE create_time BETWEEN '2023-01-01' AND '2023-12-31'`（索引有效）
- **选择区分度高的列建立索引**：区分度指索引列中不同值的数量占总数的比例。比例越高（如主键、唯一索引），区分度越好，索引过滤的数据越多，效果越明显。像“性别”这种只有“男”、“女”两种值的列，区分度极低，创建索引意义不大
- **避免过度索引**：索引不是越多越好。每个额外的索引都会增加磁盘空间占用，并降低写操作（`INSERT`/`UPDATE`/`DELETE`）的速度，因为数据库需要维护索引结构
- **注意索引列的顺序**：对于`ORDER BY`和`GROUP BY`，索引的列顺序非常重要。如果查询是`ORDER BY A, B`，那么索引`(A, B)`会比`(B, A)`更有效